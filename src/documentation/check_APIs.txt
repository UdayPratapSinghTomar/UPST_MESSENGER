how i update message status delivered and also how i update read ??-
-Complete DM features with read receipts

To fully support delivered and read receipts in your chat app (like WhatsApp/Teams), you need to:

âœ… Update the MessageStatus table when a message reaches a user â†’ delivered
âœ… Update the MessageStatus when the user actually views the message â†’ read
âœ… Use Socket.IO (or HTTP) events so client informs server of delivery/read
âœ… Broadcast the updated status back to everyone in the chat

Below is a complete pattern for DELIVERED and READ message status in Sequelize/Express/Socket.IO.

ğŸ“Œ 1) How MessageStatus Works (Your Schema)

Your MessageStatus table tracks status for every message_id and user_id, e.g.:

message_id	user_id	status
10	5	"sent"
10	6	"delivered"
10	6	"read"

Here status can be sent, delivered, or read, just like real chat apps.

ğŸ›  2) API: Mark Message as Delivered

â–¶ When a userâ€™s client receives the message (e.g., gets new message event), send this API call:

Route
router.post('/message/delivered', auth, controller.markAsDelivered);

Controller
exports.markAsDelivered = async (req, res) => {
  try {
    const { message_id, chat_id } = req.body;
    const userId = req.user.id;
    const io = req.app.get('io');

    // Update only if status was sent â†’ now delivered
    await MessageStatus.update(
      { status: 'delivered', delivered_at: new Date() },
      {
        where: {
          message_id,
          user_id: userId,
          chat_id,
          status: 'sent'
        }
      }
    );

    // Notify clients in chat room
    io.to(`chat_${chat_id}`).emit('message_status_update', {
      message_id,
      user_id: userId,
      status: 'delivered'
    });

    return sendResponse(res, 200, true, 'Message marked delivered');
  } catch (err) {
    return sendResponse(res, 500, false, 'Server error', null, { server: err.message });
  }
};


ğŸ‘‰ This takes the message and the current user and updates MessageStatus.
Then it emits a socket event so everyone in the chat sees the status change.

ğŸ›  3) API: Mark Message as Read

â–¶ When the user views the message (e.g., opens chat or scrolls it into view):

Route
router.post('/message/read', auth, controller.markAsRead);

Controller
exports.markAsRead = async (req, res) => {
  try {
    const { message_id, chat_id } = req.body;
    const userId = req.user.id;
    const io = req.app.get('io');

    await MessageStatus.update(
      { status: 'read', read_at: new Date() },
      {
        where: {
          message_id,
          user_id: userId,
          chat_id,
          status: { [Op.in]: ['sent', 'delivered'] }
        }
      }
    );

    io.to(`chat_${chat_id}`).emit('message_status_update', {
      message_id,
      user_id: userId,
      status: 'read'
    });

    return sendResponse(res, 200, true, 'Message marked read');
  } catch (err) {
    return sendResponse(res, 500, false, 'Server error', null, { server: err.message });
  }
};

ğŸš€ 4) Client Event Flow

Your frontend should trigger these:

â­ Delivered

On receiving new messages via socket:

socket.on('NEW_MESSAGE', (message) => {
  // mark delivered
  axios.post('/message/delivered', {
    message_id: message.id,
    chat_id: message.chat_id
  });
});

â­ Read

When user views messages (e.g., opens chat or scrolls to bottom):

axios.post('/message/read', {
  message_id: lastVisibleMessageId,
  chat_id
});


You might also emit through Socket.IO instead of HTTP â€” that works too as long as server handles the event.

ğŸ“¡ 5) Broadcasting to All Users

Server emits:

io.to(`chat_${chat_id}`).emit('message_status_update', {
  message_id,
  user_id,
  status
});


So on frontend:

socket.on('message_status_update', ({ message_id, user_id, status }) => {
  // update UI for that message and user
});

ğŸ§  Summary
âœ… What gets updated:
Action	Updates DB to	Broadcast
Message created	sent	NEW_MESSAGE
Client received (local)	delivered	message_status_update
Client viewed/read	read	message_status_update

This mirrors real chat features like WhatsAppâ€™s single/double ticks and blue ticks.

ğŸ“Œ Considerations

ğŸ”¹ Delivered typically means the socket client has connected and received the message.

ğŸ”¹ Read means the user actually saw it (not just received). This is usually triggered on view event.

ğŸ”¹ You may want to batch update statuses for many messages when opening a chat (mark all unread as read).

ğŸ§© Implementation Tips

âœ” Use sequelize.Op.in to update multiple possible existing status cases.
âœ” Use timestamps (read_at, delivered_at) for precise UI timing.
âœ” Handle offline clients gracefully (store status updates when they reconnect).

If you want, I can show you how to do this with Socket.IO events instead of REST endpoints, which is even smoother for a real-time chat app.