‚úÖ STEP 1: START YOUR SERVER
1Ô∏è‚É£ Open terminal in project root
node server.js


You should see:

Server running on port 5000


‚ö†Ô∏è If you get DB error ‚Üí PostgreSQL is not running or credentials wrong.

‚úÖ STEP 2: OPEN POSTMAN

Create a New Collection
Name it:

Chat App Backend

üß™ TEST 1 ‚Äî REGISTER USER
‚û§ Endpoint
POST http://localhost:5000/api/auth/register

‚û§ Headers
Content-Type: application/json

‚û§ Body ‚Üí raw ‚Üí JSON
{
  "name": "Uday",
  "email": "uday@test.com",
  "password": "123456"
}

‚û§ Click SEND
‚úÖ Expected Response
{
  "id": "...",
  "name": "Uday",
  "email": "uday@test.com",
  "password": "hashed..."
}


‚úî User saved in database
‚úî Password encrypted

üß™ TEST 2 ‚Äî REGISTER SECOND USER (IMPORTANT)

We need 2 users to chat.

Endpoint
POST http://localhost:5000/api/auth/register

Body
{
  "name": "Rahul",
  "email": "rahul@test.com",
  "password": "123456"
}


‚úî Now you have 2 users

üß™ TEST 3 ‚Äî LOGIN USER
Endpoint
POST http://localhost:5000/api/auth/login

Body
{
  "email": "uday@test.com",
  "password": "123456"
}

‚úÖ Expected Response
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}


Test 1 -
üìå IMPORTANT

Copy this token

We will use it in next steps

üß™ TEST 4 ‚Äî CHECK DATABASE (OPTIONAL BUT GOOD)

Open pgAdmin or psql
Check tables:

SELECT * FROM "Users";


You should see both users.

üß™ TEST 5 ‚Äî CREATE PRIVATE CHAT

‚ö†Ô∏è Right now this will FAIL because we haven‚Äôt added JWT middleware yet.

That‚Äôs GOOD.

This is why STEP 1 (Auth Middleware) is next.

‚ùó COMMON ERRORS & FIXES
‚ùå Server not starting

Check .env

PostgreSQL running?

‚ùå Sequelize error

Database chatdb exists?

CREATE DATABASE chatdb;

üéØ WHAT YOU HAVE SUCCESSFULLY DONE

‚úî Express server
‚úî PostgreSQL connection
‚úî Sequelize models
‚úî User registration
‚úî User login
‚úî JWT token generation

This is REAL backend work, not tutorial junk.

=======================================================================================================

Test 2 - 
1Ô∏è‚É£ LOGIN FIRST

Copy JWT token

2Ô∏è‚É£ CREATE PRIVATE CHAT
‚û§ Endpoint
POST http://localhost:5000/api/chat/private

‚û§ Headers
Content-Type: application/json
Authorization: Bearer YOUR_JWT_TOKEN

‚û§ Body (RAW ‚Üí JSON)
{
  "userId": "SECOND_USER_ID"
}


üìå Get userId from DB or register response.

‚úÖ SUCCESS RESPONSE
{
  "id": "chat-uuid",
  "type": "private",
  "createdAt": "...",
  "updatedAt": "..."
}

üß™ VERIFY IN DATABASE
SELECT * FROM "Chats";
SELECT * FROM "ChatMembers";


‚úî Chat created
‚úî Both users added

‚ùå COMMON ERRORS
‚ùå 401 Unauthorized

Token missing

Token expired

Wrong Authorization format

‚úî Correct format:

Authorization: Bearer eyJhbGciOi...

üéâ WHAT YOU JUST BUILT

‚úî JWT middleware
‚úî Protected routes
‚úî Secure chat creation
‚úî Real-world auth flow

This is exactly how production apps work.

=======================================================================================================

Test 3 - 

1Ô∏è‚É£ SEND MESSAGE
‚û§ Endpoint
POST http://localhost:5000/api/message

‚û§ Headers
Content-Type: application/json
Authorization: Bearer YOUR_JWT_TOKEN

‚û§ Body
{
  "chatId": "CHAT_ID",
  "content": "Hello from backend!",
  "type": "text"
}

‚úÖ Response
{
  "id": "...",
  "chatId": "...",
  "senderId": "...",
  "content": "Hello from backend!"
}

2Ô∏è‚É£ FETCH OLD MESSAGES
‚û§ Endpoint
GET http://localhost:5000/api/message/CHAT_ID

‚û§ Headers
Authorization: Bearer YOUR_JWT_TOKEN

‚úÖ Response
[
  {
    "content": "Hello from backend!",
    "senderId": "..."
  }
]

üîç VERIFY DATABASE
SELECT * FROM "Messages";


‚úî Messages stored permanently
‚úî History works like WhatsApp

üéâ WHAT YOU ACHIEVED

‚úî Secure message sending
‚úî Chat membership validation
‚úî Message persistence
‚úî Chat history loading

This is core WhatsApp backend logic.

‚û§ Send TEXT message
{
  "chatId": "CHAT_ID",
  "type": "text",
  "content": "Hello WhatsApp backend!"
}

‚û§ Send IMAGE message
{
  "chatId": "CHAT_ID",
  "type": "image",
  "fileUrl": "https://cdn.example.com/image.jpg"
}

‚û§ Reply to a message
{
  "chatId": "CHAT_ID",
  "type": "text",
  "content": "This is a reply",
  "replyToMessageId": "MESSAGE_ID"
}

=======================================================================================================

Test 4 - 
1Ô∏è‚É£ TEST ONLINE / OFFLINE

Start server

Connect socket (using testSocket.js)

Check DB:

SELECT name, isOnline, lastSeen FROM "Users";


‚úî When socket connected ‚Üí isOnline = true
‚úî When stopped ‚Üí isOnline = false, lastSeen updated

2Ô∏è‚É£ TEST TYPING INDICATOR
In testSocket.js, ADD:
socket.emit('typing', 'CHAT_ID')

setTimeout(() => {
  socket.emit('stop_typing', 'CHAT_ID')
}, 3000)

socket.on('user_typing', (data) => {
  console.log('Typing:', data)
})

socket.on('user_stop_typing', (data) => {
  console.log('Stopped typing:', data)
})


‚úî You‚Äôll see typing events in console
‚úî Same logic frontend will use

üéâ WHAT YOU HAVE NOW

‚úî Online / offline status
‚úî Last seen like WhatsApp
‚úî Typing indicator
‚úî Real-time updates

This is core real-time presence system.
=======================================================================================================

Test 5 -
1Ô∏è‚É£ Send message (Socket)

‚úî Status created automatically

2Ô∏è‚É£ Check DB
SELECT * FROM "MessageStatuses";


You‚Äôll see:

sent
delivered
read

3Ô∏è‚É£ Simulate delivery
socket.emit('message_delivered', {
  messageId: 'MESSAGE_ID'
})

4Ô∏è‚É£ Simulate read
socket.emit('message_read', {
  chatId: 'CHAT_ID'
})
=======================================================================================================

Test 6 -
1Ô∏è‚É£ CREATE GROUP
POST /api/chat/group

Headers
Authorization: Bearer TOKEN

Body
{
  "name": "Backend Developers",
  "members": ["USER_ID_1", "USER_ID_2"]
}


‚úî Creator becomes admin
‚úî Others are members

2Ô∏è‚É£ ADD MEMBER
POST /api/chat/group/add

{
  "chatId": "GROUP_CHAT_ID",
  "userId": "NEW_USER_ID"
}


‚úî Only admin allowed

3Ô∏è‚É£ REMOVE MEMBER
POST /api/chat/group/remove

{
  "chatId": "GROUP_CHAT_ID",
  "userId": "USER_ID_TO_REMOVE"
}

üîç VERIFY DATABASE
SELECT * FROM "Chats" WHERE type='group';
SELECT * FROM "ChatMembers";

=======================================================================================================

Test 7 -
1Ô∏è‚É£ UPLOAD FILE
‚û§ Endpoint
POST http://localhost:5000/api/media/upload

‚û§ Headers
Authorization: Bearer YOUR_JWT_TOKEN

‚û§ Body

Select form-data

Key: file

Type: File

Choose image/video/audio/pdf

‚úÖ Response
{
  "fileUrl": "http://localhost:5000/uploads/abc123.jpg",
  "fileType": "image/jpeg"
}


üìå Copy fileUrl

2Ô∏è‚É£ SEND MEDIA MESSAGE
POST http://localhost:5000/api/message

{
  "chatId": "CHAT_ID",
  "type": "image",
  "fileUrl": "http://localhost:5000/uploads/abc123.jpg"
}


‚úî Media message saved
‚úî Works with socket too

üß™ SOCKET MEDIA MESSAGE
socket.emit('send_message', {
  chatId: 'CHAT_ID',
  type: 'video',
  fileUrl: 'http://localhost:5000/uploads/video.mp4'
})

=======================================================================================================

Test 8 -
